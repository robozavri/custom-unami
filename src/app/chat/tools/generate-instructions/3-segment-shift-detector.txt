
tool: get-detect-segment-shifts

Build a TypeScript tool named get-detect-segment-shifts for Umami analytics.
This tool finds significant share shifts in traffic/behavior by segment (e.g., country, device, browser, referrer_domain, utm_source, path) by comparing the current window to the previous window of equal length. All statistics run in code; the DB adapter returns only segment totals for the chosen metric.

Goals

Input: websiteId, date range, segment keys, metric → Output: list of segment shift findings.

DB-agnostic via an adapter; implement a Postgres adapter now, ClickHouse stub later.

Robust thresholds using effect size in percentage points and optional chi-square for categorical share changes.

Provide unit tests with synthetic data.

Purpose: Identify behavior shifts by segment (country, device, browser, referrer_domain, utm_source, path).

Input:
{
  "metric": "visits|pageviews|bounce_rate|conv_rate",
  "segment_by": "country|device|browser|referrer_domain|utm_source|path",
  "websiteId": "uuid (optional)",
  "date_from": "YYYY-MM-DD",
  "date_to": "YYYY-MM-DD",
  "min_share": 0.05
}

Method (formula)
Compute segment shares s_i = metric_i / sum(metric_i).
Compare current period vs. previous period: Δs_i = s_i(curr) − s_i(prev).
Flag segments with |Δs_i| ≥ threshold and/or chi-square test p < 0.05.

sql but you must write database agnostic query. here example:
/* Current */
WITH cur AS (
  SELECT country, countDistinct(visit_id) AS visits
  FROM umami.website_event
  WHERE website_id = {websiteId:UUID}
    AND created_at >= parseDateTimeBestEffort('{date_from}')
    AND created_at <  parseDateTimeBestEffort('{date_to}') + INTERVAL 1 DAY
  GROUP BY country
),
tot AS (SELECT sum(visits) AS total FROM cur)
SELECT
  country,
  visits / total AS share_curr
FROM cur, tot;

/* Do the same for the previous period; then join and compute delta shares. */

Output:
{
  "shifts": [
    { "segment_by":"country", "segment":"US", "share_change": +0.12, "p_value": 0.01,
      "note": "US share up 12pp; check paid campaigns" }
  ]
}

1) API & JSON Schema
export type SegmentKey =
  | "country"
  | "device"
  | "browser"
  | "referrer_domain"
  | "utm_source"
  | "path";

export type SegmentMetric = "visits" | "pageviews" | "bounce_rate";

export interface SegmentShiftInput {
  websiteId: string;                 // required
  date_from: string;                 // "YYYY-MM-DD"
  date_to: string;                   // "YYYY-MM-DD"
  segment_by: SegmentKey | SegmentKey[]; // single key or list (iterate keys)
  metric?: SegmentMetric;            // default "visits"
  timezone?: string;                 // default "UTC"
  min_effect_size?: number;          // default 0.15 (15 percentage points)
  min_share?: number;                // default 0.05 (segment must be ≥5% in curr or prev to consider)
  min_support?: number;              // default 100 (sum over segments in each window)
  use_chi_square?: boolean;          // default true (adds statistical test over counts)
  normalize_labels?: boolean;        // default true (e.g., lowercase labels)
}

export interface SegmentShiftFinding {
  type: "shift";
  metric: SegmentMetric;
  segment_by: SegmentKey;
  label: string;                     // the segment label (e.g., "US")
  value: number;                     // current share (0..1) or rate for bounce_rate case
  expected: number;                  // previous share (0..1) or previous rate
  effect_size: number;               // abs(value - expected)
  p_value?: number;                  // chi-square p-value if available
  support_curr: number;              // total denominator in current window
  support_prev: number;              // total denominator in previous window
  explanation: string;               // human-friendly summary
  recommended_checks: string[];      // e.g., campaign/geo checks
}

export interface SegmentShiftOutput {
  findings: SegmentShiftFinding[];
  summary: string;
  extras?: {
    current?: Array<{ label: string; value: number }>;
    previous?: Array<{ label: string; value: number }>;
  };
}


tool schema:
{
  "name": "detect-segment-shifts",
  "description": "Detects significant share shifts by segment (country, device, browser, referrer_domain, utm_source, path) comparing current vs previous window.",
  "input_schema": {
    "type": "object",
    "required": ["websiteId", "date_from", "date_to", "segment_by"],
    "properties": {
      "websiteId": { "type": "string" },
      "date_from": { "type": "string", "pattern": "^\\d{4}-\\d{2}-\\d{2}$" },
      "date_to":   { "type": "string", "pattern": "^\\d{4}-\\d{2}-\\d{2}$" },
      "segment_by": {
        "oneOf": [
          { "type": "string", "enum": ["country","device","browser","referrer_domain","utm_source","path"] },
          { "type": "array", "items": { "type": "string", "enum": ["country","device","browser","referrer_domain","utm_source","path"] } }
        ]
      },
      "metric": { "type": "string", "enum": ["visits","pageviews","bounce_rate"], "default": "visits" },
      "timezone": { "type": "string", "default": "UTC" },
      "min_effect_size": { "type": "number", "default": 0.15 },
      "min_share": { "type": "number", "default": 0.05 },
      "min_support": { "type": "number", "default": 100 },
      "use_chi_square": { "type": "boolean", "default": true },
      "normalize_labels": { "type": "boolean", "default": true }
    }
  }
}

2) Adapter contract (DB-agnostic)
export interface SegmentTotal { label: string; value: number } // value is a count, not a share
export type SegmentMetric = "visits" | "pageviews" | "bounce_rate";
export type SegmentKey =
  | "country"
  | "device"
  | "browser"
  | "referrer_domain"
  | "utm_source"
  | "path";

export interface SegmentSource {
  fetchSegmentTotals(params: {
    websiteId: string;
    metric: SegmentMetric;         // "visits" | "pageviews" | "bounce_rate"
    segment_by: SegmentKey;
    date_from: string;
    date_to: string;
    timezone?: string;
    normalize_labels?: boolean;
  }): Promise<SegmentTotal[]>;
}

Notes:

For "visits": return count of distinct visit_id per label.

For "pageviews": return pageview events count per label.

For "bounce_rate": return pair of counts per label OR encode as value = bounces and include visits in a separate call. To keep the interface simple and DB-agnostic, implement bounce rate with two internal calls:

fetchSegmentTotals(metric="visits")

fetchSegmentTotals(metric="pageviews") and compute bounces per visit in TS (or add an extra adapter method if you already precompute bounces by label).
If that’s awkward, restrict the initial version to "visits" and "pageviews"; you can add "bounce_rate" later as a follow-up.

3) Formula & detection logic

We compare share of each segment label in current vs previous windows:

Let C_i be the current count for label i and C = Σ_i C_i.

Let P_i be the previous count for label i and P = Σ_i P_i.

Share (current): s_i = C_i / C

Share (previous): s'_i = P_i / P

Effect size (pp): Δ_i = s_i − s'_i (absolute value used for threshold)

Filter: consider label i only if s_i ≥ min_share OR s'_i ≥ min_share, and both totals C ≥ min_support and P ≥ min_support.

Optional chi-square (categorical shift):
A simple 2×k chi-square can be computed, or we compute per-label p-values via a 2×2 table:

	label i	other
current	C_i	C−C_i
previous	P_i	P−P_i

Compute χ² or Fisher (approx) and derive p_value. Flag when p_value < 0.05 and |Δ_i| ≥ min_effect_size.

Interpretation:

Positive Δ → segment share increased (e.g., US from 20% → 35%, Δ=+15pp).

Negative Δ → segment share decreased; also worth investigating.

4) Implementation example (TypeScript)
import {
  SegmentShiftInput, SegmentShiftFinding, SegmentShiftOutput,
  SegmentKey, SegmentMetric
} from "../../types.segmentShifts";
import { SegmentSource, SegmentTotal } from "../../adapters/base";

function toMap(rows: SegmentTotal[]): Map<string, number> {
  const m = new Map<string, number>();
  for (const r of rows) m.set(normalize(r.label), (m.get(normalize(r.label)) ?? 0) + (r.value ?? 0));
  return m;
}
const normalize = (s: string) => s?.toLowerCase?.() ?? s;

function chiSquarePValue(a: number, b: number, c: number, d: number): number {
  // 2x2 chi-square with Yates continuity correction (approx); DB-agnostic and dependency-free
  // a=C_i, b=C-C_i, c=P_i, d=P-P_i
  const n = a + b + c + d;
  const ad = a * d, bc = b * c;
  const num = Math.abs(ad - bc) - n / 2;
  const x2 = (n * Math.pow(num, 2)) / ((a + b) * (c + d) * (a + c) * (b + d) + 1e-9);
  // Convert x2 to p-value with df=1 using complementary error function approx
  // p ≈ exp(-x2/2) * (1 + x2/2) (upper tail approximation)
  const p = Math.exp(-x2 / 2) * (1 + x2 / 2);
  return Math.min(Math.max(p, 0), 1);
}

export async function detectSegmentShifts(
  src: SegmentSource,
  input: SegmentShiftInput
): Promise<SegmentShiftOutput> {
  const metric: SegmentMetric = input.metric ?? "visits";
  const tz = input.timezone ?? "UTC";
  const min_effect = input.min_effect_size ?? 0.15;
  const min_share = input.min_share ?? 0.05;
  const min_support = input.min_support ?? 100;
  const use_chi = input.use_chi_square ?? true;

  const segmentKeys: SegmentKey[] = Array.isArray(input.segment_by)
    ? input.segment_by
    : [input.segment_by];

  const prev = previousWindow(input.date_from, input.date_to);
  const findings: SegmentShiftFinding[] = [];

  for (const segment_by of segmentKeys) {
    // Fetch current & previous totals by label
    const currentRows = await src.fetchSegmentTotals({
      websiteId: input.websiteId, metric, segment_by,
      date_from: input.date_from, date_to: input.date_to,
      timezone: tz, normalize_labels: input.normalize_labels ?? true
    });
    const previousRows = await src.fetchSegmentTotals({
      websiteId: input.websiteId, metric, segment_by,
      date_from: prev.from, date_to: prev.to,
      timezone: tz, normalize_labels: input.normalize_labels ?? true
    });

    const curMap = toMap(currentRows);
    const prevMap = toMap(previousRows);
    const C = [...curMap.values()].reduce((s,v)=>s+v, 0);
    const P = [...prevMap.values()].reduce((s,v)=>s+v, 0);

    if (C < min_support || P < min_support) {
      continue; // not enough data
    }

    // Compute shares and deltas
    const labels = new Set([...curMap.keys(), ...prevMap.keys()]);
    for (const label of labels) {
      const Ci = curMap.get(label) ?? 0;
      const Pi = prevMap.get(label) ?? 0;
      const s  = C > 0 ? Ci / C : 0;
      const sp = P > 0 ? Pi / P : 0;

      if (s < min_share && sp < min_share) continue;

      const delta = s - sp; // >0 means share increased
      const absDelta = Math.abs(delta);

      if (absDelta >= min_effect) {
        let pval: number | undefined = undefined;
        if (use_chi) {
          const a = Ci, b = C - Ci, c = Pi, d = P - Pi;
          pval = chiSquarePValue(a,b,c,d);
          // Require both practical significance and statistical support
          if (pval >= 0.05) continue;
        }

        findings.push({
          type: "shift",
          metric,
          segment_by,
          label,
          value: s,
          expected: sp,
          effect_size: absDelta,
          p_value: pval,
          support_curr: C,
          support_prev: P,
          explanation: `${segment_by}=${label} share ${delta >= 0 ? "increased" : "decreased"} by ${(absDelta*100).toFixed(0)}pp (${(sp*100).toFixed(0)}% → ${(s*100).toFixed(0)}%)`,
          recommended_checks: [
            "inspect campaigns/referrers",
            "review geo/device targeting",
            "check landing page relevance"
          ]
        });
      }
    }
  }

  // Rank by effect size then by support
  findings.sort((a,b)=>{
    if (b.effect_size !== a.effect_size) return b.effect_size - a.effect_size;
    const sa = a.support_curr + a.support_prev;
    const sb = b.support_curr + b.support_prev;
    return sb - sa;
  });

  const summary = findings.length
    ? `Detected ${findings.length} segment shift(s). Top: ${findings[0].segment_by}=${findings[0].label} ${(findings[0].effect_size*100).toFixed(0)}pp change.`
    : "No significant segment shifts detected for the selected period.";

  return {
    findings,
    summary,
    extras: {
      current: [],  // optional: return currentRows as-is if you want charts
      previous: []
    }
  };
}

// Utility: compute previous window with equal length
function previousWindow(date_from: string, date_to: string) {
  const from = new Date(date_from + "T00:00:00Z");
  const to = new Date(date_to + "T00:00:00Z");
  const days = Math.round((+to - +from)/86400000) + 1;
  const prevTo = new Date(+from - 86400000);
  const prevFrom = new Date(+prevTo - (days-1)*86400000);
  const iso = (d: Date) => d.toISOString().slice(0,10);
  return { from: iso(prevFrom), to: iso(prevTo) };
}

5) Postgres SQL sketch (parameterized) for fetchSegmentTotals

Create src/adapters/postgres.ts implementing SegmentSource via pg. Assume a generic events table with columns:

website_id uuid, visit_id text/uuid, event_type text, created_at timestamptz,

segment columns exist (e.g., country, device, browser, referrer_domain, utm_source, url_path or path).

Visits (distinct sessions) by segment:
!notice and dont forget you must write database agnostic queries
-- params: $1=websiteId, $2=date_from, $3=date_to, $4=timezone, $5=segment_by
SELECT
  CASE WHEN $6::bool THEN lower(seg) ELSE seg END AS label,
  COUNT(DISTINCT visit_id)::bigint AS value
FROM (
  SELECT
    CASE
      WHEN $5 = 'country' THEN country
      WHEN $5 = 'device' THEN device
      WHEN $5 = 'browser' THEN browser
      WHEN $5 = 'referrer_domain' THEN referrer_domain
      WHEN $5 = 'utm_source' THEN utm_source
      WHEN $5 = 'path' THEN url_path
    END AS seg,
    visit_id
  FROM events
  WHERE website_id = $1
    AND created_at >= $2::timestamptz
    AND created_at <  ($3::timestamptz + interval '1 day')
) t
GROUP BY label;

Pageviews by segment:

SELECT
  CASE WHEN $6::bool THEN lower(seg) ELSE seg END AS label,
  COUNT(*)::bigint AS value
FROM (
  SELECT
    CASE
      WHEN $5 = 'country' THEN country
      WHEN $5 = 'device' THEN device
      WHEN $5 = 'browser' THEN browser
      WHEN $5 = 'referrer_domain' THEN referrer_domain
      WHEN $5 = 'utm_source' THEN utm_source
      WHEN $5 = 'path' THEN url_path
    END AS seg
  FROM events
  WHERE website_id = $1
    AND event_type = 'pageview'
    AND created_at >= $2::timestamptz
    AND created_at <  ($3::timestamptz + interval '1 day')
) t
GROUP BY label;

Bounce rate: initially skip at the adapter level unless you’re ready to compute per-label bounces (visits with exactly 1 pageview). You can add an extra adapter method later (returns {label, visits, bounces}), then compute bounces/visits per label in TS.

ClickHouse hints (stub later):

Replace COUNT(DISTINCT visit_id) with uniq(visit_id).

Use direct grouping on the chosen segment column.

Time filters in UTC or with toTimeZone(created_at, tz) if needed.

6) Example usage:
import { detectSegmentShifts } from "./tools/checks/segments";
import { PgSegmentSource } from "./adapters/postgres";

const src = new PgSegmentSource(pgPool, { table: "umami.website_event" });

const out = await detectSegmentShifts(src, {
  websiteId: "b1d1c8d0-...-.....",
  date_from: "2025-08-01",
  date_to: "2025-08-14",
  segment_by: ["country","device","utm_source"],
  metric: "visits",
  min_effect_size: 0.12,     // 12pp
  min_share: 0.05,
  min_support: 500,
  use_chi_square: true,
  normalize_labels: true
});

console.log(out.summary);
console.table(out.findings.map(f => ({
  segment_by: f.segment_by, label: f.label,
  curr: (f.value*100).toFixed(1)+"%",
  prev: (f.expected*100).toFixed(1)+"%",
  delta_pp: (f.effect_size*100).toFixed(1),
  p: f.p_value?.toFixed(4)
})));

7) Tests (synthetic)

Create tests/checks.segments.test.ts:

Case 1: Current window country shares: US 0.40, DE 0.20, others 0.40; Previous: US 0.25, DE 0.25, others 0.50 → Expect findings for US (+15pp) and maybe others (−10pp) if ≥ threshold.
Case 2: Device “mobile” share drops 20pp → flagged.
Case 3: min_share excludes tiny labels.
Case 4: Chi-square p<0.05 required when use_chi_square=true.
Case 5: Low min_support results in no findings.

Mock the adapter to return totals; no DB needed for tests.

8) Acceptance Criteria

detect-segment-shifts returns:
summary string and correct findings[] when synthetic shifts exist.
Each finding includes segment_by, label, value (current share), expected (previous share), effect_size, and optional p_value.
Postgres adapter compiles with parameterized queries; no SQL injection.
ClickHouse adapter stub exists with TODO notes.
No DB-specific logic inside the detector; only in adapters.
















